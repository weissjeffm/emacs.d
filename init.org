# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+TITLE: Emacs configuration
#+AUTHOR: Jeff Weiss
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args :tangle yes
* Setup
** Bootstrap
When this configuration is loaded for the first time, the
~init-first-time.el~ is the file that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle init-first-time.el
  ;; This file replaces itself with the actual configuration at first run.

  ;; We can't tangle without org!
  (require 'org)
  ;; Open the configuration
  (find-file (concat user-emacs-directory "init.org"))
  ;; tangle it
  (org-babel-tangle)
  ;; load it
  (load-file (concat user-emacs-directory "init.el"))
  ;; finally byte-compile it
  (byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

In order for it to be bootstrapped, that file should be renamed to
~init.el~ before emacs starts. My git repo has an init.el in it
already with the contents above, so no need to do anything except
start emacs if you've cloned my repo.

As soon as emacs starts, ~init.el~ will be overwritten with the
configuration specified in this file.
** Development of this configuration
A little script to create a fresh .emacs.d, copy this file into it,
and start a new emacs process.

#+BEGIN_SRC sh
  INITDIR=~/test/.emacs.d
  rm -rf $INITDIR
  mkdir -p $INITDIR
  cp ~/.emacs.d/init-first-time.el $INITDIR/init.el
  rm $INITDIR/init.elc
  cp ~/.emacs.d/init.org $INITDIR
  HOME=~/test/
  /Applications/Emacs-Plus/Contents/MacOS/Emacs --debug-init &
#+END_SRC
* Theme
All the custom colors and fonts that I prefer.
#+BEGIN_SRC emacs-lisp
  (deftheme jweiss
    "Created 2015-09-08.")

  (custom-theme-set-faces
   'jweiss
   '(notmuch-search-count ((t (:inherit default :foreground "light gray"))))
   '(notmuch-search-date ((t (:inherit default :foreground "cyan"))))
   '(notmuch-search-subject ((t (:inherit default :foreground "DarkSeaGreen2"))))
   '(ac-completion-face ((t (:inherit default :foreground "darkgray" :underline t))))
   '(clojure-keyword-face ((t (:inherit lisp-keyword))))
   '(secondary-selection ((t (:background "gray11"))))
   '(fixed-pitch ((t (:inherit default))))
   '(hl-line ((t (:inherit highlight :background "#151500"))))
   '(rcirc-timestamp ((t (:inherit default :background "black" :foreground "gray25"))))
   '(region ((t (:background "#57230c"))))
   '(variable-pitch ((t (:inherit default :family "DejaVu Sans"))))
   '(show-paren-match ((t (:background "#292903"))))
   '(org-level-1 ((t (:foreground "white" :height 1.75 :weight bold :inherit outline-1))))
   '(org-level-2 ((t (:foreground "gray80" :height 1.5 :weight bold :inherit outline-2))))
   '(org-level-3 ((t (:foreground "gray60" :height 1.25 :weight bold :inherit outline-3))))
   '(org-level-4 ((t (:foreground "gray40" :height 1.1 :weight bold :inherit outline-4))))
   '(double-quote ((t (:foreground "LightSalmon"))))
   '(font-lock-string-face ((t (:foreground "#ffddaa"))))
   '(lisp-parens ((t (:foreground "gray32" :bold t :underline nil))))
   '(lisp-keyword ((t (:foreground "#ffcccc" :italic t))))
   '(font-lock-keyword-face ((t (:foreground "#eeaaff" :bold t))))
   '(font-lock-function-name-face ((t (:foreground "#ffeeaa" :bold t))))
   '(font-lock-builtin-face ((t (:foreground "#aaddff" :bold t))))
   '(clojure-brackets ((t (:foreground "#445f5f" :bold t))))
   '(clojure-braces ((t (:foreground "#5f4d44" :bold t))))
   '(clojure-java-call ((t (:foreground "#ccffcc"))))
   '(clojure-namespace ((t (:foreground "#0000ff" :bold t))))
   '(clojure-special ((t (:foreground "#bbbbff" :bold t :italic t))))
   '(default ((t (:background "black" :foreground "white" :slant normal :weight normal :family "DejaVu Sans Mono")))))

  (setq custom-safe-themes '("3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa" default))
  (provide-theme 'jweiss)
  (enable-theme 'jweiss)
#+END_SRC

* Global Builtin Settings
** Don't save customizations to init.el
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "customizations.el"))
#+END_SRC
** Include /usr/local on path
#+BEGIN_SRC emacs-lisp
  (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
  (setq exec-path (append exec-path '("/usr/local/bin")))
#+END_SRC

** Unbind some keys that have unwanted behavior
#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-z")) ;; suspend
  (global-unset-key (kbd "s-p")) ;; print (hangs emacs on macos?)
#+END_SRC

** Change some global keybindings
Make them more convenient or easier to reach

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-q") 'ivy-switch-buffer) ;; switch buffer in an easy combo
  (global-set-key (kbd "<f5>") 'revert-buffer) ;; reload a buffer

  ;; frame switching with shift-arrow keys
  (global-set-key (kbd "S-<left>") 'windmove-left)
  (global-set-key (kbd "S-<right>") 'windmove-right)
  (global-set-key (kbd "S-<up>") 'windmove-up)
  (global-set-key (kbd "S-<down>") 'windmove-down)

  ;; Font size
  (define-key global-map (kbd "C-+") 'text-scale-increase)
  (define-key global-map (kbd "C--") 'text-scale-decrease)
#+END_SRC

** Use y/n instead of yes/no
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable graphical decorations
By default, emacs has a graphical toolbar, a scrollbar on the
right, and a menu. We don't need any of that stuff.
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC
** Highlight current line and s-expression
Add a subtle highlight to the line that point is on, and also add
additional highlighting to the expression that point is on.
#+BEGIN_SRC emacs-lisp
  (hl-line-mode t)
  (show-paren-mode)
  (setq show-paren-priority 0
     show-paren-style 'expression)
#+END_SRC
** Frame Splitting
Split the current frame either horizontally or vertically, depending
on whether the frame is wide or tall. Good for emacs installations
that may be run on vertical and horizontal monitors.
#+BEGIN_SRC emacs-lisp
  (defun resplit-frame ()
    (interactive)
    (delete-other-windows)
    (if (> (frame-pixel-width)
           (frame-pixel-height))
        (split-window-right)
      (split-window-below)))

  (global-set-key (kbd "C-c r") 'resplit-frame)
#+END_SRC
** Use ibuffer for buffer list
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'ibuffer)
#+END_SRC
** Save backup and undo files in a specific subdirectory
Save to hidden dir .~ instead of making files go everywhere.
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . ".~")))
  (setq undo-tree-history-directory-alist '(("." . ".~")))
#+END_SRC
** Forward ssh agent with TRAMP
#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (defun add-ssh-agent-to-tramp ()
    (cl-pushnew '("-A")
                (cadr (assoc 'tramp-login-args
                             (assoc "ssh" tramp-methods)))
                :test #'equal))
  (add-ssh-agent-to-tramp)
#+END_SRC
** Copy current buffer file name to kill ring
#+BEGIN_SRC emacs-lisp
  (defun clip-file ()
    "Put the current file name on the clipboard"
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        (file-name-directory default-directory)
                      (buffer-file-name))))
      (if filename
          (progn (kill-new filename)
                 (x-select-text filename))
        (error "unable to determine file name of current buffer."))))
#+END_SRC
** Don't save buffers before grepping
This is highly annoying and I don't understand why it's the default.

#+BEGIN_SRC emacs-lisp
  (setq grep-save-buffers nil)
#+END_SRC
* Features and Extensions
To install new features, we need to load the =package= system. =cl= is
a library that contains many functions from Common Lisp, and comes in
handy quite often, so we want to make sure it's loaded, along with
=package=, which is obviously needed.


#+BEGIN_SRC emacs-lisp
  (require 'cl)
  (require 'package)
#+END_SRC

There are several package repositories, we will specify which ones we
want to use and then initialize the package system so it's ready to
install any packages that might be missing.

#+BEGIN_SRC emacs-lisp
  ;; add repositories
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  ;;(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (add-to-list 'package-archives '("org". "http://orgmode.org/elpa/"))

  ;; initialize packages
  (package-initialize)
  (package-refresh-contents nil)
#+END_SRC

Once =package= is loaded we can add =use-package= on top, which
provides a lot of flexibility.

#+BEGIN_SRC emacs-lisp
  (package-install 'use-package)
  ;; This is only needed once, near the top of the file
  (require 'use-package)

  (setq use-package-always-ensure t) ;; always install package if not present
#+END_SRC


Now we're ready to start loading and configuring individual features.
** Visual Style
*** Mode Line
We'll use Powerline to set up the mode line.
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line-powerline-theme
    :pin melpa-stable
    :config
    (sml/setup)
    (setq powerline-default-separator 'arrow-fade
          sml/theme 'smart-mode-line-powerline))
#+END_SRC

*** New faces
This macro will let us easily define new "faces" later.

#+BEGIN_SRC emacs-lisp
  (defmacro def-mode-face (name color desc &optional others)
    `(defface ,name '((((class color)) (:foreground ,color ,@others)))
       ,desc :group 'faces))
#+END_SRC

** General Editing
*** Completion
For automatic completion and narrowing of candidates, we'll use [[https://github.com/abo-abo/swiper][Ivy]]
(also contains functionality called Swiper and Counsel).

This tool helps you choose from lists, for things like selecting a
buffer, finding a file, finding a command, etc.

Swiper shows all of the occurrences of a particular regex in one
place, it can be a replacement for the builtin ~re-search-forward~.

~counsel-git-grep~ is a replacement for ~find-grep~.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :pin melpa-stable
    :config
    (setq
     ;; for showing recently used first
     ivy-use-virtual-buffers t
     ;; make ivy's display a bit bigger
     ivy-height 30)
    (when (eq system-type 'darwin)
      ;; use appropriate search backend for OS X
      (setq counsel-locate-cmd 'counsel-locate-cmd-mdfind))
    :bind
    (("C-s" . 'swiper)
     ("M-x" . 'counsel-M-x)
     ("C-x C-f" . 'counsel-find-file)
     ("C-c j" . 'counsel-git-grep)))
#+END_SRC

#+RESULTS:
: counsel-git-grep

*** Autocomplete
Autocomplete will help you finish what you started typing. For
example, long function names. When you hit TAB autocomplete will
fill in the rest. We'll try company-mode.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :pin melpa-stable
    :hook (after-init . global-company-mode))
#+END_SRC
*** Smartparens
Smartparens inserts parens in pairs, keeps them balanced, and provides
motion and structural editing. It's a must-have for any lisp
programming.
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :pin melpa-stable
    :config
    (require 'smartparens-config)
    (setq sp-base-key-bindings 'paredit
          sp-highlight-pair-overlay nil
          sp-highlight-wrap-overlay nil
          sp-highlight-wrap-tag-overlay nil)
    (sp-pair "(" ")" :wrap "M-(")
    (sp-pair "[" "]" :wrap "M-[")
    (sp-pair "{" "}" :wrap "M-{")

    :bind
    (:map smartparens-mode-map
          ("C-M-<backspace>" . sp-backward-kill-sexp)
          ("M-s" . sp-splice-sexp)
          ("M-S-<up>" . sp-raise-sexp)
          ("C-<right>" . sp-forward-slurp-sexp)
          ("C-<left>" . sp-forward-barf-sexp)
          ("C-M-<left>" . sp-backward-slurp-sexp)
          ("C-M-<right>" . sp-backward-barf-sexp)
          ("C-M-n" . sp-up-sexp)
          ("C-M-p" . sp-backward-down-sexp)
          ("C-M-d" . sp-down-sexp)
          ("C-M-u" . sp-backward-up-sexp)))
#+END_SRC

#+RESULTS:
: smartparens-config

Set up smartparens to run in strict mode in these major modes (where
it doesn't allow parens to become unbalanced!)
#+BEGIN_SRC emacs-lisp
  (dolist (mode '(scheme emacs-lisp lisp clojure clojurescript eshell html cider-repl))
      (add-hook (intern (concat (symbol-name mode) "-mode-hook"))
                #'smartparens-strict-mode))
#+END_SRC

**** Focus Mode
My own little experiment using smartparens and emacs' built in
narrowing to focus on a particular s-expression. It has commands to
narrow or expand the focus.
#+BEGIN_SRC emacs-lisp
  (defun narrow-to-expression ()
    (interactive)
    (mark-sexp)
    (narrow-to-region (point) (mark))
    (deactivate-mark t))

  (defun focus-lisp-movement (motion-fn)
    (widen)
    (let ((pt (point)))
      (funcall motion-fn)
      (if (not (eq pt (point)))
          (narrow-to-expression))
      (deactivate-mark t)))

  (defun focus-lisp-up ()
    (interactive)
    (focus-lisp-movement 'sp-backward-up-sexp))

  (defun focus-lisp-down ()
    (interactive)
    (focus-lisp-movement 'sp-down-sexp))

  (define-key smartparens-mode-map (kbd "C-M-S-U") 'focus-lisp-up)
  (define-key smartparens-mode-map (kbd "C-M-S-D") 'focus-lisp-down)
  (define-key smartparens-mode-map (kbd "C-M-u") 'sp-backward-up-sexp)
  (global-set-key (kbd "C-x n e") 'narrow-to-expression)
#+END_SRC

*** Undo Tree
Allows you to undo and redo without losing any previous states.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree) ;; this is in elpa, so no need to pin
  (autoload 'global-undo-tree-mode "undo-tree")
  (global-undo-tree-mode)
  (setq undo-tree-auto-save-history t
        undo-tree-visualizer-timestamps t)
#+END_SRC
*** Multiple cursors
A powerful tool that allows you to perform any edit operation in many
places simultaneously. It's great for making the same structural edits
repeatedly. Same functionality as keyboard macros, but allows you to
see the results at each step.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :pin melpa-stable)
  (require 'multiple-cursors)
  (define-prefix-command 'mc-key-map)
  (global-set-key (kbd "C-c m") 'mc-key-map)

  (define-key mc-key-map (kbd ".") 'mc/mark-all-symbols-like-this)
  (define-key mc-key-map (kbd "M-.") 'mc/mark-all-symbols-like-this-in-defun)
  (define-key mc-key-map (kbd ",") 'mc/mark-all-like-this-dwim)
  (define-key mc-key-map (kbd "/") 'mc/mark-more-like-this-extended)
  (define-key mc-key-map (kbd "s") 'mc/mark-next-symbol-like-this)
  (define-key mc-key-map (kbd "m") 'mc/mark-all-dwim)
  (define-key mc/keymap (kbd "M-n") 'mc/cycle-forward)

  ;; don't exit with the return key
  (define-key mc/keymap (kbd "<return>") nil)
#+END_SRC

Remember which commands need to be run once for each cursor (normally
saved to ~.mc-lists.el~
#+BEGIN_SRC emacs-lisp
  (setq mc/cmds-to-run-for-all
        '(backward-sexp
          beginning-of-defun
          cljr-slash
          down-list
          forward-sexp
          indent-new-comment-line
          kill-sexp
          sp-backward-delete-char
          sp-backward-up-sexp
          sp-down-sexp
          sp-forward-slurp-sexp
          sp-raise-sexp
          sp-remove-active-pair-overlay
          sp-splice-sexp
          sp-unwrap-sexp
          sp-up-sexp
          down-list
          forward-sexp
          sp-backward-delete-char
          sp-backward-up-sexp
          sp-forward-slurp-sexp
          sp-raise-sexp
          sp-splice-sexp
          sp-unwrap-sexp)
        mc/cmds-to-run-once
        '(cider-load-buffer))
#+END_SRC

*** Ace Jump Mode
Lets you jump anywhere on screen with a few keypresses.

#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :pin melpa-stable)

  ;; org mode move keybinding out of way
  (define-key org-mode-map (kbd "C-'") nil)

  (global-set-key (kbd "C-'") 'ace-jump-mode)
  (setq ace-jump-mode-scope 'frame) ;;current frame only
  (setq ace-jump-mode-move-keys ;;lower case hotkeys only
        (loop for i from ?a to ?z collect i))
#+END_SRC

** Org mode
There are a few features we want, to be able to write org mode
documents like this one.

org-babel is what allows you to execute code blocks inside the org
mode file. There are some add ons for different languages.

#+BEGIN_SRC emacs-lisp
  (require 'ob-clojure)
  (setq org-babel-load-languages '((emacs-lisp . t) (shell . t))
        org-confirm-babel-evaluate nil
        org-startup-indented t
        org-startup-with-inline-images t)
#+END_SRC

Install HTMLize so that we can export files like this one to HTML
and get pretty fonts and colors just like we see in emacs!

#+BEGIN_SRC emacs-lisp
    (use-package htmlize
      :pin melpa-stable)
#+END_SRC

Next we enable bullets mode which makes pretty bulleted outlines,
instead of just using the asterisk character.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :pin melpa-stable)
  (require 'org-bullets)
  (setq org-bullets-bullet-list '("●" "○" "★"))
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

** Source Control
Magit is the best. It's a wrapper for git, and it makes things so much easier.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :pin melpa-stable)
  (require 'magit)
  (global-set-key (kbd "<f2>") 'magit-status)
  (setq magit-diff-refine-hunk 'all
        magit-revert-buffers 'silent
        magit-save-repository-buffers nil
        magit-completing-read-function 'ivy-completing-read)
#+END_SRC

Add the ability to jump right into magit from find-file, so you can
go to the repository and straight to magit. ~M-o g~ will jump to
magit from whatever the current candidate is.
#+BEGIN_SRC emacs-lisp
  (ivy-add-actions 'counsel-find-file '(("g" magit-status "magit")))
#+END_SRC


** Programming Languages
*** Generic Lisp
There are some features that apply to all flavors of Lisp, including
Emacs Lisp, Common Lisp, and Clojure. We'll define them once and apply
them to the whole lisp family.

**** Colors for keywords, parens, and quotes
It's nice to have the quote character be a slightly different color
than the text it's enclosing.

Lisp keywords (that start with ~:~) are easier to pick out if they are
a different color from normal lisp symbols.

Dimming parens to a dark gray is great, as a lisp programmer you tend
to stop looking at them and only notice the indent level most of the
time.

#+BEGIN_SRC emacs-lisp
  (setq my-lisp-font-lock-keywords
        '(("(\\|)" . 'lisp-parens)
          ("\\s-+:\\w+" . 'lisp-keyword)
          ("#?\"" 0 'double-quote prepend)))

  (def-mode-face double-quote "#00920A" "special")
  (def-mode-face lisp-keyword "#45b8f2" "Lisp keywords")
  (def-mode-face lisp-parens "DimGrey" "Lisp parens")

  (font-lock-add-keywords 'lisp-mode my-lisp-font-lock-keywords)

#+END_SRC
**** Highlight symbols
:PROPERTIES:
:CUSTOM_ID: highlight-symbol
:END:
This is a feature that highlights all the occurrences of the symbol at
point, so that you can see where else that symbol is used. We'll use
autoload so that we only load the feature when it's called upon.
#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
    :pin melpa-stable
    :config
    ;; highlight occurrences of the symbol in this color
    (set-face-attribute 'highlight-symbol-face nil :background "DarkOrange3"))

#+END_SRC
*** Emacs Lisp
We'll add features to Emacs Lisp first since that's what we're using
to add functionality to everything else.

Enable completion when reading an elisp expression from the minibuffer.
#+BEGIN_SRC emacs-lisp
  (define-key read-expression-map (kbd "TAB") 'completion-at-point)
#+END_SRC

For navigating elisp, jumping into functions and back, we'll use the
slime nav style, which means using ~M-.~ and ~M-,~. Enable it in
~ielm-mode~ too (an elisp REPL).
#+BEGIN_SRC emacs-lisp
  (use-package elisp-slime-nav
    :pin melpa-stable)
  (require 'elisp-slime-nav)
  (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
    (add-hook hook 'elisp-slime-nav-mode))
#+END_SRC

Use eldoc in elisp mode. Eldoc is what displays function signatures in
the echo area, so we can see what arguments a function expects.
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

Use special colors for parens, keywords, and quotes, as we defined
earlier for generic lisp.

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'emacs-lisp-mode my-lisp-font-lock-keywords)
#+END_SRC
*** Clojure
First set up the clojure mode, and its hook to define some extra
behavior in clojure mode:

+ ~imenu~ - bring up a menu of top-level symbols defined in this
  namespace, with completion
+ Disable ~kill-sentence~ which doesn't make sense in structured text
  like lisp. It will end up unbalancing parens and generally making a
  mess.
+ Use [[#highlight-symbol][highlight-symbol]] mode, and bind some keys for jumping to
  next/previous occurrence
+ Use clj-refactor which adds refactor tools like ~require~
  management, renaming, etc.

  #+BEGIN_SRC emacs-lisp
    (use-package clojure-mode
      :pin melpa-stable)
    (use-package clj-refactor
      :pin melpa-stable)
    (autoload 'clojure-mode "clojure-mode")
    (autoload 'clojure-mode-map "clojure-mode" nil nil 'keymap)
    (autoload 'clj-refactor-mode "clj-refactor")
    (add-hook 'clojure-mode-hook
              (lambda ()
                ;;(define-key clojure-mode-map (kbd "<return>") 'sp-forward-sexp)
                ;; imenu keybind
                (define-key clojure-mode-map (kbd "C-c i") 'imenu)
                ;; disable kill-sentence
                (define-key global-map (kbd "M-k") nil)
                ;;enable clojure refactor
                (clj-refactor-mode 1)
                (yas-minor-mode 1)
                ;; highlight symbols
                (highlight-symbol-mode 1)
                (define-key clojure-mode-map (kbd "C-M-,") 'highlight-symbol-prev)
                (define-key clojure-mode-map (kbd "C-M-.") 'highlight-symbol-next)))
  #+END_SRC

  Add the same sort of extra highlighting for clojure that we have for
  generic lisp, but add some extra features (such as different
  highlighting for square and curly braces, booleans etc).
  #+BEGIN_SRC emacs-lisp
    (setq my-clojure-font-lock-keywords
          (nconc my-lisp-font-lock-keywords
                 '(("#?\\^?{\\|}" . 'clojure-braces)
                   ("\\[\\|\\]" . 'clojure-brackets)
                   ("nil\\|true\\|false\\|%[1-9]?" . 'clojure-special)
                   ("(\\(\\.[^ \n)]*\\|[^ \n)]+\\.\\|new\\)\\([ )\n]\\|$\\)" 1 'clojure-java-call)
                   ("\\<\\(FIXME\\|TODO\\|BUG\\):" 1 'font-lock-warning-face t))))
    (font-lock-add-keywords 'clojure-mode my-clojure-font-lock-keywords)
    (font-lock-add-keywords 'clojurescript-mode my-clojure-font-lock-keywords)

    ;; Define extra clojure faces
    (def-mode-face clojure-braces "#49b2c7" "Clojure braces")
    (def-mode-face clojure-brackets "#0074e8" "Clojure brackets")
    (def-mode-face clojure-namespace "#a9937a" "Clojure namespace")
    (def-mode-face clojure-java-call "#7587a6" "Clojure Java calls")
    (def-mode-face clojure-special "#0074e8" "Clojure special")

    (font-lock-add-keywords 'clojure-mode my-clojure-font-lock-keywords)
  #+END_SRC
**** Interactive Development
For interactive programming with clojure, use cider. Use eldoc mode in
the repl to display function signatures. Allow execution of clojure
code blocks in org-mode files.

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :pin melpa) ;; remote connection bug only in melpa
  ;; switch back to stable at 0.19

  (autoload 'cider-repl-mode "cider")
  (font-lock-add-keywords 'cider-repl-mode my-clojure-font-lock-keywords)
  (add-hook 'cider-repl-mode-hook #'eldoc-mode)
  (setq org-babel-clojure-backend 'cider)
  (global-set-key (kbd "<f12\>") 'cider-jack-in)
  (setq cider-default-cljs-repl 'figwheel
        cider-lein-parameters "trampoline with-profile +dev repl :headless")
#+END_SRC

For some reason remote repls sometimes are unreachable, this will go
in through ssh if necessary
#+BEGIN_SRC emacs-lisp
  (setq nrepl-use-ssh-fallback-for-remote-hosts t)
#+END_SRC

Bind keys to inspect results of last evaluation
#+BEGIN_SRC emacs-lisp
  (define-key clojure-mode-map (kbd "C-c M-I") 'cider-inspect-last-result)
  (define-key cider-mode-map (kbd "C-c M-I") 'cider-inspect-last-result)
#+END_SRC

Bind key to manually start completion
#+BEGIN_SRC emacs-lisp
  (define-key clojure-mode-map (kbd "<backtab>") 'company-complete)
  (define-key cider-repl-mode-map (kbd "<backtab>") 'company-complete)
#+END_SRC
*** Rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :pin melpa-stable)

  (use-package ob-rust)

  (use-package cargo
    :pin melpa-stable)
#+END_SRC

#+RESULTS:

** OS Interaction
*** File Browsing
We'll use the builtin dired for this, and extend it a bit.

Add dired as an option to find-file, so we can jump right into a
directory display (~M-o d~).

#+BEGIN_SRC emacs-lisp
  (ivy-add-actions 'counsel-find-file '(("d" dired "dired")))
#+END_SRC
** Messaging
*** Email
For email client, we'll use notmuch. I've heard mu4e is good too, but
i've already got some config for notmuch.
#+BEGIN_SRC emacs-lisp
  (use-package notmuch
    :pin melpa-stable)

  (setq
   ;; Show newest mail first
   notmuch-search-oldest-first nil
   ;; Use comma for thousands separator instead of odd-looking space
   notmuch-hello-thousands-separator ","
   ;; Use internal for finding address book entries
   notmuch-address-command 'internal
   ;; not sure what these do but seems important
   notmuch-crypto-process-mime t
   notmuch-show-all-multipart/alternative-parts nil
   notmuch-saved-searches '((:name "Inbox" :query "tag:new")))
#+END_SRC

Also add a new function to remove the "new" tag for all the messages
currently displayed. Otherwise the inbox just keeps growing and growing.

#+BEGIN_SRC emacs-lisp
  (defun notmuch-untag-all-new ()
    (interactive)
    (notmuch-search-tag-all '("-new"))
    (notmuch-bury-or-kill-this-buffer))
  (define-key notmuch-search-mode-map (kbd "C-c C-k") 'notmuch-untag-all-new)
#+END_SRC

*** Rest Client
I like to use restclient.el so I can stay in emacs instead of going to
a graphical client like postman, or something basic like curl.

org-mode supports restclient if you add the babel mode for
restclient. Doesn't look like there's a package for it, but the code
is so short i'll just include it all here, and then add the setup at
the end.
#+BEGIN_SRC emacs-lisp
  (use-package restclient)
  (use-package ob-restclient)
  ;; setup
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((restclient . t)))
#+END_SRC
*** IRC
For IRC client we'll use good old built-in rcirc. 
#+BEGIN_SRC emacs-lisp :tangle no
  ;; linux only for now due to reliance on secrets.el
  (when (eq system-type 'gnu/linux)
    (require 'secrets)

    (setq
     rcirc-buffer-maximum-lines 2000
     rcirc-default-full-name "Jeff Weiss"
     rcirc-default-user-name "jweiss"
     rcirc-fill-column 'frame-width
     rcirc-fill-flag nil
     rcirc-log-flag t
     rcirc-notify-check-frame nil
     rcirc-notify-message "%s: %s"
     rcirc-notify-message-private "(priv) %s: %s"
     rcirc-notify-timeout 30
     rcirc-time-format "%D %H:%M "
     rcirc-track-minor-mode t

     ;; Personal settings - sensitive data is stored in OS keychain, which
     ;; we can access with secrets library
     rcirc-authinfo `(("irc.freenode.net" nickserv
                       ,(secrets-get-attribute "Login" "Freenode irc" :user)
                       ,(secrets-get-secret "Login" "Freenode irc")))
     rcirc-server-alist
     `(("irc.freenode.net" :channels
        ,(first (read-from-string (secrets-get-attribute  "Login" "Freenode irc" :channels)))))))
#+END_SRC
