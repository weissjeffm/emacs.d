# -*- mode: org; -*-
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <style> pre.src { background: black; color: white; } #content { max-width: 1000px } </style>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+TITLE: Emacs configuration
#+AUTHOR: Jeff Weiss
#+BABEL: :cache yes
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args :tangle yes
* Setup
** Bootstrap
When this configuration is loaded for the first time, the
~init-first-time.el~ is the file that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle init-first-time.el
  ;; This file replaces itself with the actual configuration at first run.

  ;; We can't tangle without org!
  (require 'org)
  ;; Open the configuration
  (find-file (concat user-emacs-directory "init.org"))
  ;; tangle it
  (org-babel-tangle)
  ;; load it
  (load-file (concat user-emacs-directory "init.el"))
  ;; finally byte-compile it
  (byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

In order for it to be bootstrapped, that file should be renamed to
~init.el~ before emacs starts. My git repo has an init.el in it
already with the contents above, so no need to do anything except
start emacs if you've cloned my repo.

As soon as emacs starts, ~init.el~ will be overwritten with the
configuration specified in this file.
** Development of this configuration
A little script to create a fresh .emacs.d, copy this file into it,
and start a new emacs process.

#+BEGIN_SRC sh
  INITDIR=~/test/.emacs.d
  rm -rf $INITDIR
  mkdir -p $INITDIR
  cp ~/.emacs.d/init-first-time.el $INITDIR/init.el
  rm $INITDIR/init.elc
  cp ~/.emacs.d/init.org $INITDIR
  HOME=~/test/
  /Applications/Emacs-Plus/Contents/MacOS/Emacs --debug-init &
#+END_SRC
* Theme
All the custom colors and fonts that I prefer.
#+BEGIN_SRC emacs-lisp
  (deftheme jweiss
    "Created 2015-09-08.")

  (custom-theme-set-faces
   'jweiss
   '(ac-completion-face ((t (:inherit default :foreground "darkgray" :underline t))))
   '(clojure-keyword-face ((t (:inherit lisp-keyword))))
   '(secondary-selection ((t (:background "gray11"))))
   '(fixed-pitch ((t (:inherit default))))
   '(hl-line ((t (:inherit highlight :background "#151500"))))
   '(rcirc-timestamp ((t (:inherit default :background "black" :foreground "gray25"))))
   '(region ((t (:background "#57230c"))))
   '(variable-pitch ((t (:inherit default :family "DejaVu Sans"))))
   '(show-paren-match ((t (:background "#292903"))))
   '(org-level-1 ((t (:foreground "white" :height 1.75 :weight bold :inherit outline-1))))
   '(org-level-2 ((t (:foreground "gray80" :height 1.5 :weight bold :inherit outline-2))))
   '(org-level-3 ((t (:foreground "gray60" :height 1.25 :weight bold :inherit outline-3))))
   '(org-level-4 ((t (:foreground "gray40" :height 1.1 :weight bold :inherit outline-4))))
   '(double-quote ((t (:foreground "LightSalmon"))))
   '(font-lock-string-face ((t (:foreground "#ffddaa"))))
   '(lisp-parens ((t (:foreground "gray32" :bold t :underline nil))))
   '(lisp-keyword ((t (:foreground "#ffcccc" :italic t))))
   '(font-lock-keyword-face ((t (:foreground "#eeaaff" :bold t))))
   '(font-lock-function-name-face ((t (:foreground "#ffeeaa" :bold t))))
   '(font-lock-builtin-face ((t (:foreground "#aaddff" :bold t))))
   '(clojure-brackets ((t (:foreground "#445f5f" :bold t))))
   '(clojure-braces ((t (:foreground "#5f4d44" :bold t))))
   '(clojure-java-call ((t (:foreground "#ccffcc"))))
   '(clojure-namespace ((t (:foreground "#0000ff" :bold t))))
   '(clojure-special ((t (:foreground "#bbbbff" :bold t :italic t))))
   '(default ((t (:background "black" :foreground "white" :slant normal :weight normal :family "DejaVu Sans Mono")))))

  (setq custom-safe-themes '("3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa" default))
  (provide-theme 'jweiss)
  (enable-theme 'jweiss)
#+END_SRC

* Global Builtin Settings
** Don't save customizations to init.el
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "customizations.el"))
  (condition-case nil 
      (load custom-file)
    (error (message "customizations file couldn't be loaded (does it exist?)")))
#+END_SRC
** Include /usr/local on path
#+BEGIN_SRC emacs-lisp
  (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
  (setq exec-path (append exec-path '("/usr/local/bin")))
#+END_SRC

** Unbind some keys that have unwanted behavior
#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-z")) ;; suspend
  (global-unset-key (kbd "C-x C-z")) ;; suspend frame
  (global-unset-key (kbd "s-p")) ;; print (hangs emacs on macos?)
#+END_SRC

** Change some global keybindings
Make them more convenient or easier to reach

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-q") 'ivy-switch-buffer) ;; switch buffer in an easy combo
  (global-set-key (kbd "<f5>") 'revert-buffer) ;; reload a buffer

  ;; frame switching with shift-arrow keys
  (global-set-key (kbd "S-<left>") 'windmove-left)
  (global-set-key (kbd "S-<right>") 'windmove-right)
  (global-set-key (kbd "S-<up>") 'windmove-up)
  (global-set-key (kbd "S-<down>") 'windmove-down)

  ;; Font size
  (define-key global-map (kbd "C-+") 'text-scale-increase)
  (define-key global-map (kbd "C--") 'text-scale-decrease)
#+END_SRC

** Use y/n instead of yes/no
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable graphical decorations
By default, emacs has a graphical toolbar, a scrollbar on the
right, and a menu. We don't need any of that stuff.
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC
** Highlight current line and s-expression
Add a subtle highlight to the line that point is on, and also add
additional highlighting to the expression that point is on.
#+BEGIN_SRC emacs-lisp
  (hl-line-mode t)
  (show-paren-mode)
  (setq show-paren-priority 0
     show-paren-style 'expression)
#+END_SRC
** Add column number at left of modeline
#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC
** Frame Splitting
Split the current frame either horizontally or vertically, depending
on whether the frame is wide or tall. Good for emacs installations
that may be run on vertical and horizontal monitors.
#+BEGIN_SRC emacs-lisp
  (defun resplit-frame ()
    (interactive)
    (delete-other-windows)
    (if (> (frame-pixel-width)
           (frame-pixel-height))
        (split-window-right)
      (split-window-below)))

  (global-set-key (kbd "C-c r") 'resplit-frame)
#+END_SRC
** Use ibuffer for buffer list
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'ibuffer)
#+END_SRC
** Save backup and undo files in a specific subdirectory
Save to hidden dir .~ instead of making files go everywhere.
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . ".~")))
  (setq undo-tree-history-directory-alist '(("." . ".~")))
#+END_SRC
** TRAMP
*** Forward ssh agent
#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (defun add-ssh-agent-to-tramp ()
    (cl-pushnew '("-A")
                (cadr (assoc 'tramp-login-args
                             (assoc "ssh" tramp-methods)))
                :test #'equal))
  (add-ssh-agent-to-tramp)
#+END_SRC
*** Performance
#+BEGIN_SRC emacs-lisp
  ;; Don't try to do other version control systems besides git
  (setq vc-handled-backends '(Git))
  ;; Reduce logging for perf reasons
  (setq tramp-verbose 1)
#+END_SRC
** Copy current buffer file name to kill ring
#+BEGIN_SRC emacs-lisp
  (defun clip-file ()
    "Put the current file name on the clipboard"
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        (file-name-directory default-directory)
                      (buffer-file-name))))
      (if filename
          (progn (kill-new filename)
                 (x-select-text filename))
        (error "unable to determine file name of current buffer."))))
#+END_SRC
** Don't save buffers before grepping
This is highly annoying and I don't understand why it's the default.

#+BEGIN_SRC emacs-lisp
  (setq grep-save-buffers nil)
#+END_SRC
** Bind key for joining to previous line
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-u") 'delete-indentation)
#+END_SRC
* Features and Extensions
To install new features, we need to load the =package= system. =cl= is
a library that contains many functions from Common Lisp, and comes in
handy quite often, so we want to make sure it's loaded, along with
=package=, which is obviously needed.


#+BEGIN_SRC emacs-lisp
  (require 'cl)
  (require 'package)
#+END_SRC

There are several package repositories, we will specify which ones we
want to use and then initialize the package system so it's ready to
install any packages that might be missing.

#+BEGIN_SRC emacs-lisp
  ;; add repositories
  (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  ;;(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (add-to-list 'package-archives '("org". "http://orgmode.org/elpa/"))

  ;; initialize packages
  (package-initialize)
  (package-refresh-contents nil)
#+END_SRC

Once =package= is loaded we can add =use-package= on top, which
provides a lot of flexibility.

#+BEGIN_SRC emacs-lisp
  (package-install 'use-package)
  ;; This is only needed once, near the top of the file
  (require 'use-package)

  (setq use-package-always-ensure t) ;; always install package if not present
#+END_SRC


Now we're ready to start loading and configuring individual features.
** Visual Style
*** Mode Line
We'll use Powerline to set up the mode line.
#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :config
    (setq powerline-default-separator 'wave)
    (setq powerline-display-mule-info nil)
    (defface cjp-powerline-yellow '((t (:background "#ffcc66" :foreground "#2d2d2d" :inherit mode-line :weight bold)))
      "Powerline yellow face.")

    ;; Same as powerline-default-theme, but move some of the items about a bit
    (setq-default mode-line-format
                  '("%e"
                    (:eval
                     (let* ((active (powerline-selected-window-active))
                            (mode-line (if active 'mode-line 'mode-line-inactive))
                            (face1 (if active 'powerline-active1 'powerline-inactive1))
                            (face2 (if active 'powerline-active2 'powerline-inactive2))
                            (face-yellow (if active 'cjp-powerline-yellow 'powerline-inactive1))
                            (separator-left (intern (format "powerline-%s-%s"
                                                            (powerline-current-separator)
                                                            (car powerline-default-separator-dir))))
                            (separator-right (intern (format "powerline-%s-%s"
                                                             (powerline-current-separator)
                                                             (cdr powerline-default-separator-dir))))
                            (height 20)
                            (lhs (list (powerline-raw "%*" face-yellow 'l)
                                       (powerline-raw (concat "[" (projectile-project-name) "]") face-yellow 'l)
                                       (let ((host (file-remote-p default-directory 'host)))
                                         (when host
                                           (powerline-raw (concat "(" host ")") face-yellow 'l)))
                                       (powerline-buffer-id face-yellow 'l)
                                       (powerline-vc face-yellow 'l)
                                       (powerline-raw " " face-yellow)
                                       (funcall separator-left face-yellow face1 height)
                                       (when (boundp 'erc-modified-channels-object)
                                         (powerline-raw erc-modified-channels-object face1 'l))
                                       (powerline-major-mode face1 'l)
                                       (powerline-process face1)
                                       (powerline-minor-modes face1 'l)
                                       (powerline-narrow face1 'l)
                                       (powerline-raw " " face1)
                                       (funcall separator-left face1 face2 height)
                                       (when (and (boundp 'which-function-mode) which-function-mode)
                                         (powerline-raw which-func-current face2 'l))))
                            (rhs (list (powerline-raw global-mode-string face2 'r)
                                       (funcall separator-right face2 face1 height)
                                       (powerline-raw " " face1)
                                       (unless window-system
                                         (powerline-raw (char-to-string #xe0a1) face1 'l))
                                       (when powerline-display-buffer-size
                                         (powerline-buffer-size face1 'r))
                                       (when powerline-display-mule-info
                                         (powerline-raw mode-line-mule-info face1 'r))
                                       (powerline-raw "%4l:%2c" face1 'r)
                                       (funcall separator-right face1 mode-line height)
                                       (powerline-raw " ")
                                       (powerline-raw "%6p" nil 'r)
                                       (when powerline-display-hud
                                         (powerline-hud face-yellow face1)))))
                       (concat (powerline-render lhs)
                               (powerline-fill face2 (powerline-width rhs))
                               (powerline-render rhs)))))))
#+END_SRC

We'll also use "diminish" to use symbols for minor modes instead of the full names.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :config
    (eval-after-load "abbrev" '(diminish 'abbrev-mode " ‚í∂"))
    (eval-after-load "eldoc" '(diminish 'eldoc-mode " ‚í∫"))
    (eval-after-load "autorevert" '(diminish 'auto-revert-mode " ‚í∂"))
    (eval-after-load "cider" '(diminish 'cider-mode (quote (:eval (format " üç∫[%s]" (cider--modeline-info)))))))
#+END_SRC
*** New faces
This macro will let us easily define new "faces" later.

#+BEGIN_SRC emacs-lisp
  (defmacro def-mode-face (name color desc &optional others)
    `(defface ,name '((((class color)) (:foreground ,color ,@others)))
       ,desc :group 'faces))
#+END_SRC

** General Editing
*** Minibuffer candidate completion
For automatic completion and narrowing of candidates, we'll use [[https://github.com/abo-abo/swiper][Ivy]]
(also contains functionality called Swiper and Counsel).

This tool helps you choose from lists, for things like selecting a
buffer, finding a file, finding a command, etc.

Swiper shows all of the occurrences of a particular regex in one
place, it can be a replacement for the builtin ~re-search-forward~.

~counsel-git-grep~ is a replacement for ~find-grep~.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :pin melpa-stable
    :config
    (setq
     ;; for showing recently used first
     ivy-use-virtual-buffers t
     ;; make ivy's display a bit bigger
     ivy-height 30
     ;; ignore backup files
     counsel-find-file-ignore-regexp "\\(?:\\`\\|[/\\]\\)\\(?:[#.]\\)")
    (when (eq system-type 'darwin)
      ;; use appropriate search backend for OS X
      (setq counsel-locate-cmd 'counsel-locate-cmd-mdfind))
    :bind
    (("C-s" . 'swiper)
     ("C-c C-s" . 'swiper-all)
     ("M-x" . 'counsel-M-x)
     ("C-x C-f" . 'counsel-find-file)
     ("C-c j" . 'counsel-git-grep)
     ("C-c i" . 'counsel-imenu)))
#+END_SRC

#+RESULTS:
: counsel-git-grep

*** Autocomplete
Autocomplete will help you finish what you started typing. For
example, long function names. When you hit TAB autocomplete will
fill in the rest. We'll try company-mode.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :pin melpa-stable
    :bind (:map company-active-map
                ("M-n" . nil)
                ("M-p" . nil)
                ("C-n" . company-select-next)
                ("C-p" . company-select-previous))
    :hook (after-init . global-company-mode)
    :diminish " üßû")

#+END_SRC
*** Smartparens
Smartparens inserts parens in pairs, keeps them balanced, and provides
motion and structural editing. It's a must-have for any lisp
programming.
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :pin melpa-stable
    :config
    (require 'smartparens-config)
    (setq sp-base-key-bindings 'paredit
          sp-highlight-pair-overlay nil
          sp-highlight-wrap-overlay nil
          sp-highlight-wrap-tag-overlay nil)
    (sp-pair "(" ")" :wrap "M-(")
    (sp-pair "[" "]" :wrap "M-[")
    (sp-pair "{" "}" :wrap "M-{")

    :bind
    (:map smartparens-mode-map
          ("C-M-<backspace>" . sp-backward-kill-sexp)
          ("C-M-s" . sp-splice-sexp)
          ("C-M-r" . sp-raise-sexp)
          ("C-M-]" . sp-forward-slurp-sexp)
          ("C-M-[" . sp-forward-barf-sexp)
          ("C-M-9" . sp-backward-slurp-sexp)
          ("C-M-0" . sp-backward-barf-sexp)
          ("C-M-n" . sp-up-sexp)
          ("C-M-p" . sp-backward-down-sexp)
          ("C-M-d" . sp-down-sexp)
          ("C-M-u" . sp-backward-up-sexp))
    :diminish " ‚íÆ")
#+END_SRC

#+RESULTS:
: smartparens-config

Set up smartparens to run in strict mode in these major modes (where
it doesn't allow parens to become unbalanced!)
#+BEGIN_SRC emacs-lisp
  (dolist (mode '(scheme emacs-lisp lisp clojure clojurescript eshell html cider-repl go))
      (add-hook (intern (concat (symbol-name mode) "-mode-hook"))
                #'smartparens-strict-mode))
#+END_SRC

**** Focus Mode
My own little experiment using smartparens and emacs' built in
narrowing to focus on a particular s-expression. It has commands to
narrow or expand the focus.
#+BEGIN_SRC emacs-lisp

  (defun narrow-to-expression ()
    (interactive)
    (mark-sexp)
    (narrow-to-region (point) (mark))
    (deactivate-mark t))

  (defun focus-lisp-movement (motion-fn)
    (widen)
    (let ((pt (point)))
      (funcall motion-fn)
      (if (not (eq pt (point)))
          (narrow-to-expression))
      (deactivate-mark t)))

  (defun focus-lisp-up ()
    (interactive)
    (focus-lisp-movement 'sp-backward-up-sexp))

  (defun focus-lisp-down ()
    (interactive)
    (focus-lisp-movement 'sp-down-sexp))

  (define-key smartparens-mode-map (kbd "C-M-S-U") 'focus-lisp-up)
  (define-key smartparens-mode-map (kbd "C-M-S-D") 'focus-lisp-down)
  (define-key smartparens-mode-map (kbd "C-M-u") 'sp-backward-up-sexp)
  (global-set-key (kbd "C-x n e") 'narrow-to-expression)
#+END_SRC

*** Undo Tree
Allows you to undo and redo without losing any previous states.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish " ‚éåüå≤") ;; this is in elpa, so no need to pin
  (autoload 'global-undo-tree-mode "undo-tree")
  (global-undo-tree-mode)
  (setq undo-tree-auto-save-history t
        undo-tree-visualizer-timestamps t)
#+END_SRC

*** Cursor movement undo
It's very common to move the point accidentally to the wrong place, or
jump somewhere and then need to jump back. We'll use the package
`point-stack` for this, which keeps track of previous positions (even
across buffers but within the same window).
#+BEGIN_SRC emacs-lisp
  (use-package point-stack
    :config (add-hook 'pre-command-hook
                      (lambda ()
                        (unless (or (eq this-command 'point-stack-forward-stack-pop)
                                    (eq this-command 'point-stack-pop))
                          (point-stack-push))))
            (define-key org-mode-map (kbd "C-,") nil)

    :bind (("C-." . point-stack-forward-stack-pop)
           ("C-," . point-stack-pop)))

  ;; org mode move keybinding out of way
  (require 'org)
  (define-key org-mode-map (kbd "C-,") nil)
  (define-key org-mode-map (kbd "C-.") nil)

  ;; for some reason the feature doesn't work at all until you try to
  ;; pop
  (point-stack-push)
  (point-stack-pop)
#+END_SRC
*** Multiple cursors
A powerful tool that allows you to perform any edit operation in many
places simultaneously. It's great for making the same structural edits
repeatedly. Same functionality as keyboard macros, but allows you to
see the results at each step.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :pin melpa-stable)
  (require 'multiple-cursors)
  (define-prefix-command 'mc-key-map)
  (global-set-key (kbd "C-c m") 'mc-key-map)

  (define-key mc-key-map (kbd ".") 'mc/mark-all-symbols-like-this)
  (define-key mc-key-map (kbd "M-.") 'mc/mark-all-symbols-like-this-in-defun)
  (define-key mc-key-map (kbd ",") 'mc/mark-all-like-this-dwim)
  (define-key mc-key-map (kbd "/") 'mc/mark-more-like-this-extended)
  (define-key mc-key-map (kbd "s") 'mc/mark-next-symbol-like-this)
  (define-key mc-key-map (kbd "m") 'mc/mark-all-dwim)
  (define-key mc/keymap (kbd "M-n") 'mc/cycle-forward)

  ;; don't exit with the return key
  (define-key mc/keymap (kbd "<return>") nil)
#+END_SRC

Remember which commands need to be run once for each cursor (normally
saved to ~.mc-lists.el~
#+BEGIN_SRC emacs-lisp
  (setq mc/cmds-to-run-for-all
        '(backward-sexp
          beginning-of-defun
          cljr-slash
          down-list
          forward-sexp
          indent-new-comment-line
          kill-sexp
          sp-backward-delete-char
          sp-backward-up-sexp
          sp-down-sexp
          sp-forward-slurp-sexp
          sp-raise-sexp
          sp-remove-active-pair-overlay
          sp-splice-sexp
          sp-unwrap-sexp
          sp-up-sexp
          down-list
          forward-sexp
          sp-backward-delete-char
          sp-backward-up-sexp
          sp-forward-slurp-sexp
          sp-raise-sexp
          sp-splice-sexp
          sp-unwrap-sexp)
        mc/cmds-to-run-once
        '(cider-load-buffer))
#+END_SRC

*** Ace Jump Mode
Lets you jump anywhere on screen with a few keypresses.

#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :pin melpa-stable)

  ;; org mode move keybinding out of way
  (require 'org)
  (define-key org-mode-map (kbd "C-'") nil)

  (global-set-key (kbd "C-'") 'ace-jump-mode)
  (setq ace-jump-mode-scope 'frame) ;;current frame only
  (setq ace-jump-mode-move-keys ;;lower case hotkeys only
        (loop for i from ?a to ?z collect i))
#+END_SRC

** Org mode
There are a few features we want, to be able to write org mode
documents like this one.

org-babel is what allows you to execute code blocks inside the org
mode file. There are some add ons for different languages.

#+BEGIN_SRC emacs-lisp
   (require 'ob-clojure)
   (setq org-confirm-babel-evaluate nil
         org-startup-indented t
         org-startup-with-inline-images t
         org-edit-src-content-indentation 0)
   (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t) (shell . t)))
#+END_SRC

In order to insert code templates easily using the "<s" shortcut, we
need to load org-tempo. https://orgmode.org/manual/Structure-Templates.html#Structure-Templates

#+begin_src emacs-lisp
  (require 'org-tempo)
#+end_src

Install HTMLize so that we can export files like this one to HTML
and get pretty fonts and colors just like we see in emacs!

#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :pin melpa-stable)
#+END_SRC

Next we enable bullets mode which makes pretty bulleted outlines,
instead of just using the asterisk character.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :pin melpa-stable)
  (require 'org-bullets)
  (setq org-bullets-bullet-list '("‚óè" "‚óã" "‚òÖ"))
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

Define some keys for motion that match keybinding for smartparens
motion which we'll add later.
#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map (kbd "C-M-u") 'outline-up-heading)
  (define-key org-mode-map (kbd "C-M-f") 'org-forward-heading-same-level)
  (define-key org-mode-map (kbd "C-M-b") 'org-backward-heading-same-level)
#+END_SRC

Define key for deleting subtree
#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map (kbd "C-c C-x C-s") 'org-cut-subtree)
#+END_SRC

Fix for being able to run bash scripts in org-babel both remotely AND
with bash profile properly loaded (to pick up things like
aliases). The fix here is that =org-babel-eval= has to be called with
the local part of the filename when using shebang.

#+begin_src elisp
  (defun org-babel-sh-evaluate (session body &optional params stdin cmdline)
    "Pass BODY to the Shell process in BUFFER.
  If RESULT-TYPE equals `output' then return a list of the outputs
  of the statements in BODY, if RESULT-TYPE equals `value' then
  return the value of the last statement in BODY."
    (let* ((shebang (cdr (assq :shebang params)))
           (results
            (cond
             ((or stdin cmdline)	       ; external shell script w/STDIN
              (let ((script-file (org-babel-temp-file "sh-script-"))
                    (stdin-file (org-babel-temp-file "sh-stdin-"))
                    (padline (not (string= "no" (cdr (assq :padline params))))))
                (with-temp-file script-file
                  (when shebang (insert shebang "\n"))
                  (when padline (insert "\n"))
                  (insert body))
                (set-file-modes script-file #o755)
                (with-temp-file stdin-file (insert (or stdin "")))
                (with-temp-buffer
                  (call-process-shell-command
                   (concat (if shebang script-file
                             (format "%s %s" shell-file-name script-file))
                           (and cmdline (concat " " cmdline)))
                   stdin-file
                   (current-buffer))
                  (buffer-string))))
             (session			; session evaluation
              (mapconcat
               #'org-babel-sh-strip-weird-long-prompt
               (mapcar
                #'org-trim
                (butlast
                 (org-babel-comint-with-output
                     (session org-babel-sh-eoe-output t body)
                   (dolist (line (append (split-string (org-trim body) "\n")
                                         (list org-babel-sh-eoe-indicator)))
                     (insert line)
                     (comint-send-input nil t)
                     (while (save-excursion
                              (goto-char comint-last-input-end)
                              (not (re-search-forward
                                    comint-prompt-regexp nil t)))
                       (accept-process-output
                        (get-buffer-process (current-buffer))))))
                 2))
               "\n"))
             ;; External shell script, with or without a predefined
             ;; shebang.
             ((org-string-nw-p shebang)
              (let ((script-file (org-babel-temp-file "sh-script-"))
                    (padline (not (equal "no" (cdr (assq :padline params))))))
                (with-temp-file script-file
                  (insert shebang "\n")
                  (when padline (insert "\n"))
                  (insert body))
                (set-file-modes script-file #o755)
                ;; fix is here, use tramp-file-local-name
                (org-babel-eval (tramp-file-local-name script-file) "")))
             (t
              (org-babel-eval shell-file-name (org-trim body))))))
      (when results
        (let ((result-params (cdr (assq :result-params params))))
          (org-babel-result-cond result-params
            results
            (let ((tmp-file (org-babel-temp-file "sh-")))
              (with-temp-file tmp-file (insert results))
              (org-babel-import-elisp-from-file tmp-file)))))))
#+end_src
** Source Control
Magit is the best. It's a wrapper for git, and it makes things so much easier.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :pin melpa-stable)
  (require 'magit)
  (global-set-key (kbd "<f2>") 'magit-status)
  (setq magit-diff-refine-hunk 'all
        magit-revert-buffers 'silent
        magit-save-repository-buffers nil
        magit-completing-read-function 'ivy-completing-read
        ;; without this, magit over TRAMP is super slow
        auto-revert-buffer-list-filter 'magit-auto-revert-repository-buffers-p)
#+END_SRC

Add the ability to jump right into magit from find-file, so you can
go to the repository and straight to magit. ~M-o g~ will jump to
magit from whatever the current candidate is.
#+BEGIN_SRC emacs-lisp
  (ivy-add-actions 'counsel-find-file '(("g" magit-status "magit")))
#+END_SRC

** Operate within a project
We'll use projectile to do things like find files and buffers only
within a certain project.

Add a function to switch buffers: if no prefix, within the current
project (if any). With a prefix, any buffer. Bind that function to the
usual buffer switch key.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :pin melpa-stable
    :config
    (setq projectile-completion-system 'ivy)
    (projectile-mode +1)
    :bind
    (:map projectile-mode-map
          ("C-c p" . 'projectile-command-map))
    :diminish " ‚ìü")

  (defun jmw/switch-buffer-fallback (arg)
    (interactive "P")
    (if (or arg
            (not (projectile-project-p)))
        (ivy-switch-buffer)
      (projectile-switch-to-buffer)))

  (defun jmw/find-file-fallback (arg)
    (interactive "P")
    (if (or arg
            (not (projectile-project-p)))
        (counsel-find-file)
      (projectile-find-file-dwim)))

  (global-set-key (kbd "C-q") 'jmw/switch-buffer-fallback)
  (global-set-key (kbd "C-x C-f") 'jmw/find-file-fallback)
#+END_SRC

Add the ability to jump right into projectile file finding from
find-file, so you can go to the repository and then straight to
narrowing the file list. 
#+BEGIN_SRC emacs-lisp
  (ivy-add-actions 'counsel-find-file
                   '(("f"
                      (lambda (x)
                        (let ((default-directory x))
                          (projectile-find-file-dwim)))
                      "projectile-find-file")))
#+END_SRC

** Programming Languages
*** Generic Lisp
There are some features that apply to all flavors of Lisp, including
Emacs Lisp, Common Lisp, and Clojure. We'll define them once and apply
them to the whole lisp family.
**** Return key ends expression, not line
When hitting return in lisp code, I don't want to break the line right
there, usually I want to be done with that s-expression. Due to paren
matching, the closing paren is already there. So just move out of
it. If point is already at the end of the line, then move to the next
line.

#+BEGIN_SRC emacs-lisp
  (defun jmw/lisp-return ()
    (interactive)
    (if (eolp)
        (newline)
      (sp-up-sexp)))
#+END_SRC
**** Colors for keywords, parens, and quotes
It's nice to have the quote character be a slightly different color
than the text it's enclosing.

Lisp keywords (that start with ~:~) are easier to pick out if they are
a different color from normal lisp symbols.

Dimming parens to a dark gray is great, as a lisp programmer you tend
to stop looking at them and only notice the indent level most of the
time.

#+BEGIN_SRC emacs-lisp
  (setq my-lisp-font-lock-keywords
        '(("(\\|)" . 'lisp-parens)
          ("\\s-+:\\w+" . 'lisp-keyword)
          ("#?\"" 0 'double-quote prepend)))

  (def-mode-face double-quote "#00920A" "special")
  (def-mode-face lisp-keyword "#45b8f2" "Lisp keywords")
  (def-mode-face lisp-parens "DimGrey" "Lisp parens")

  (font-lock-add-keywords 'lisp-mode my-lisp-font-lock-keywords)

#+END_SRC
**** Highlight symbols
:PROPERTIES:
:CUSTOM_ID: highlight-symbol
:END:
This is a feature that highlights all the occurrences of the symbol at
point, so that you can see where else that symbol is used. We'll use
autoload so that we only load the feature when it's called upon.
#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
    :pin melpa-stable
    :config
    ;; highlight occurrences of the symbol in this color
    (set-face-attribute 'highlight-symbol-face nil :background "DarkOrange3")
    :diminish " üÜÇ")

#+END_SRC
*** Emacs Lisp
We'll add features to Emacs Lisp first since that's what we're using
to add functionality to everything else.

Enable completion when reading an elisp expression from the minibuffer.
#+BEGIN_SRC emacs-lisp
  (define-key read-expression-map (kbd "TAB") 'completion-at-point)
#+END_SRC

For navigating elisp, jumping into functions and back, we'll use the
slime nav style, which means using ~M-.~ and ~M-,~. Enable it in
~ielm-mode~ too (an elisp REPL).
#+BEGIN_SRC emacs-lisp
  (use-package elisp-slime-nav
    :pin melpa-stable)
  (require 'elisp-slime-nav)
  (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
    (add-hook hook 'elisp-slime-nav-mode))
#+END_SRC

Use eldoc in elisp mode. Eldoc is what displays function signatures in
the echo area, so we can see what arguments a function expects.
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

Use special colors for parens, keywords, and quotes, as we defined
earlier for generic lisp.

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'emacs-lisp-mode my-lisp-font-lock-keywords)
#+END_SRC
*** Clojure
First set up the clojure mode, and its hook to define some extra
behavior in clojure mode:

+ ~imenu~ - bring up a menu of top-level symbols defined in this
  namespace, with completion
+ Disable ~kill-sentence~ which doesn't make sense in structured text
  like lisp. It will end up unbalancing parens and generally making a
  mess.
+ Use [[#highlight-symbol][highlight-symbol]] mode, and bind some keys for jumping to
  next/previous occurrence
+ Use clj-refactor which adds refactor tools like ~require~
  management, renaming, etc.

  #+BEGIN_SRC emacs-lisp
    (use-package clojure-mode
      :pin melpa-stable)
    (use-package column-enforce-mode
      :config (add-hook 'clojure-mode-hook '90-column-rule)
      :diminish " üõë")
    (use-package clj-refactor
      :pin melpa
      :diminish " ‚ìá") 
    (autoload 'clojure-mode "clojure-mode")
    (autoload 'clojure-mode-map "clojure-mode" nil nil 'keymap)
    (autoload 'clj-refactor-mode "clj-refactor")
    (add-hook 'clojure-mode-hook
              (lambda ()
                ;;(define-key clojure-mode-map (kbd "<return>") 'sp-forward-sexp)
                ;; imenu keybind
                (define-key clojure-mode-map (kbd "C-c i") 'counsel-imenu)
                ;; disable kill-sentence
                (define-key global-map (kbd "M-k") nil)
                ;;enable clojure refactor
                (clj-refactor-mode 1)
                (yas-minor-mode 1)
                ;; highlight symbols
                (highlight-symbol-mode 1)
                (define-key clojure-mode-map (kbd "C-M-,") 'highlight-symbol-prev)
                (define-key clojure-mode-map (kbd "C-M-.") 'highlight-symbol-next)
                (define-key clojure-mode-map (kbd "RET") 'jmw/lisp-return)))
  #+END_SRC

  Add the same sort of extra highlighting for clojure that we have for
  generic lisp, but add some extra features (such as different
  highlighting for square and curly braces, booleans etc).
  #+BEGIN_SRC emacs-lisp
    (setq my-clojure-font-lock-keywords
          (nconc my-lisp-font-lock-keywords
                 '(("#?\\^?{\\|}" . 'clojure-braces)
                   ("\\[\\|\\]" . 'clojure-brackets)
                   ("nil\\|true\\|false\\|%[1-9]?" . 'clojure-special)
                   ("(\\(\\.[^ \n)]*\\|[^ \n)]+\\.\\|new\\)\\([ )\n]\\|$\\)" 1 'clojure-java-call)
                   ("\\<\\(FIXME\\|TODO\\|BUG\\):" 1 'font-lock-warning-face t))))
    (font-lock-add-keywords 'clojure-mode my-clojure-font-lock-keywords)
    (font-lock-add-keywords 'clojurescript-mode my-clojure-font-lock-keywords)

    ;; Define extra clojure faces
    (def-mode-face clojure-braces "#49b2c7" "Clojure braces")
    (def-mode-face clojure-brackets "#0074e8" "Clojure brackets")
    (def-mode-face clojure-namespace "#a9937a" "Clojure namespace")
    (def-mode-face clojure-java-call "#7587a6" "Clojure Java calls")
    (def-mode-face clojure-special "#0074e8" "Clojure special")

    (font-lock-add-keywords 'clojure-mode my-clojure-font-lock-keywords)
  #+END_SRC
**** Interactive Development
For interactive programming with clojure, use cider. Use eldoc mode in
the repl to display function signatures. Allow execution of clojure
code blocks in org-mode files.

#+BEGIN_SRC emacs-lisp
  ;; when hitting enter in the repl, jump to end of next sexp, or if
  ;; we're at the end of the input, send it
  (defun jmw/cider-repl-return ()
    (interactive)
    (if (eobp)
        (cider-repl-return)
      (sp-up-sexp)))

  (use-package cider
    :bind (:map cider-repl-mode-map
                ("<return>" . jmw/cider-repl-return)))

  (autoload 'cider-repl-mode "cider")
  (font-lock-add-keywords 'cider-repl-mode my-clojure-font-lock-keywords)
  (add-hook 'cider-repl-mode-hook #'eldoc-mode)
  (setq org-babel-clojure-backend 'cider)
  (global-set-key (kbd "<f12\>") 'cider-jack-in)
  (setq cider-default-cljs-repl 'figwheel
        cider-lein-parameters "trampoline with-profile +dev repl :headless")
#+END_SRC

For some reason remote repls sometimes are unreachable, this will go
in through ssh if necessary
#+BEGIN_SRC emacs-lisp
  (setq nrepl-use-ssh-fallback-for-remote-hosts t
        nrepl-sync-request-timeout nil)
#+END_SRC

Bind keys to inspect results of last evaluation
#+BEGIN_SRC emacs-lisp
  (define-key clojure-mode-map (kbd "C-c M-I") 'cider-inspect-last-result)
  (define-key cider-repl-mode-map (kbd "C-c M-I") 'cider-inspect-last-result)
#+END_SRC

Bind key to manually start completion
#+BEGIN_SRC emacs-lisp
  (define-key clojure-mode-map (kbd "<backtab>") 'company-complete)
  (define-key cider-repl-mode-map (kbd "<backtab>") 'company-complete)
#+END_SRC
*** Rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :pin melpa-stable
    :config (add-hook 'rust-mode-hook 'smartparens-strict-mode))

  (use-package ob-rust)

  (use-package cargo
    :pin melpa-stable
    :config (add-hook 'rust-mode-hook 'cargo-minor-mode))

  (use-package flycheck-rust
    :pin melpa
    :config (add-hook 'rust-mode-hook 'flycheck-rust-load))

  (use-package racer
    :pin melpa-stable)
#+END_SRC
*** Go
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :config (add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
    :bind (:map go-mode-map ("C-c C-c" . go-run-buffer))
    :init
    (let ((gobin (concat (getenv "HOME") "/workspace/go/bin")))
            (add-to-list 'exec-path gobin)
            (setenv "PATH" (concat (getenv "PATH") ":" gobin)))
    (add-hook 'go-mode-hook (lambda ()
                              (flycheck-mode)
                              (setq tab-width 2)
                              (if (not (string-match "go" compile-command))
                                  (set (make-local-variable 'compile-command)
                                       "go build -v && go test -v && go vet")))))

  (use-package company-go)

  (use-package go-eldoc
    :init (add-hook 'go-mode-hook #'go-eldoc-setup))

  (defun go-run-buffer ()
    (interactive)
    (when (buffer-modified-p) (save-buffer))
    (shell-command (format "go run \"%s\"" (buffer-file-name) "*go run output*")))

#+END_SRC

** File formats
*** YAML
#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src
*** Markdown
#+begin_src emacs-lisp
  (use-package markdown-mode)
#+end_src
** OS Interaction
*** File Browsing
We'll use the builtin dired for this, and extend it a bit.

Add dired as an option to find-file, so we can jump right into a
directory display (~M-o d~).

#+BEGIN_SRC emacs-lisp
  (ivy-add-actions 'counsel-find-file '(("d" dired "dired")))
#+END_SRC
** Messaging
*** Email
For email client, we'll use mu4e. It needs to be installed from the
linux tarball or package, it's not an elpa package. So we just load it
from it's existing location:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
  (condition-case nil 
      (require 'mu4e)
    (error nil))
  (setq mu4e-maildir (expand-file-name "Mail" "~"))
  ;; fast index
  (setq
   mu4e-headers-fields '((:human-date . 12) (:from . 22) (:subject)) ;; columns
   mu4e-index-cleanup nil      ;; don't do a full cleanup check
   mu4e-index-lazy-check t     ;; don't consider up-to-date dirs
   mu4e-headers-skip-duplicates nil)  ;; show emails read on other machines
  ;; fetching
  (setq mu4e-get-mail-command "mbsync -a"
        mu4e-update-interval 120)
  (add-to-list 'mu4e-view-actions
               '("View in browser" . mu4e-action-view-in-browser) t)
  ;; font colors
  (custom-set-faces
   '(mu4e-header-face ((t (:inherit shadow))))
   '(mu4e-replied-face ((t (:inherit gnus-summary-high-read))))
   '(mu4e-unread-face ((t (:inherit gnus-summary-high-unread)))))
#+END_SRC
*** Rest Client
I like to use restclient.el so I can stay in emacs instead of going to
a graphical client like postman, or something basic like curl.

org-mode supports restclient if you add the babel mode for
restclient. 
#+BEGIN_SRC emacs-lisp
  (use-package restclient)
  (use-package ob-restclient)
  ;; setup
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((restclient . t)))
  ;; load the jq stuff when restclient loads
  (add-hook 'restclient-mode-hook (lambda () (require 'restclient-jq)))
#+END_SRC
*** IRC
For IRC client we'll use good old built-in rcirc.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; linux only for now due to reliance on secrets.el
  (when (eq system-type 'gnu/linux)
    (require 'secrets)

    (setq
     rcirc-buffer-maximum-lines 2000
     rcirc-default-full-name "Jeff Weiss"
     rcirc-default-user-name "jweiss"
     rcirc-fill-column 'frame-width
     rcirc-fill-flag nil
     rcirc-log-flag t
     rcirc-notify-check-frame nil
     rcirc-notify-message "%s: %s"
     rcirc-notify-message-private "(priv) %s: %s"
     rcirc-notify-timeout 30
     rcirc-time-format "%D %H:%M "
     rcirc-track-minor-mode t

     ;; Personal settings - sensitive data is stored in OS keychain, which
     ;; we can access with secrets library
     rcirc-authinfo `(("irc.freenode.net" nickserv
                       ,(secrets-get-attribute "Login" "Freenode irc" :user)
                       ,(secrets-get-secret "Login" "Freenode irc")))
     rcirc-server-alist
     `(("irc.freenode.net" :channels
        ,(first (read-from-string (secrets-get-attribute  "Login" "Freenode irc" :channels)))))))
#+END_SRC
** Calendar (outlook)
To integrate with outlook calendar, use excorporate and some elisp to copy cal entries to the diary
#+BEGIN_SRC emacs-lisp
  (use-package excorporate
    :config (progn (require 'secrets)
                   (setq-default excorporate-configuration
                                 `(,(secrets-get-attribute "Default keyring" "okta" :username) .
                                   "https://outlook.office365.com/EWS/Exchange.asmx"))
                   (setq org-agenda-include-diary t)
                   (eval-after-load "org-agenda" '(progn
                                                    (require 'excorporate)
                                                    (require 'excorporate-diary)
                                                    (excorporate)
                                                    (excorporate-diary-enable)))
                   (add-hook 'org-agenda-cleanup-fancy-diary-hook
                             (lambda ()
                               (exco-diary-diary-advice (calendar-current-date)
                                                        (calendar-current-date)
                                                        #'message "diary updated")))))
#+END_SRC
